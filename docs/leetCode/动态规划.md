# 动态规划

/**
 * 直方图面积，维护一个递增的栈，当有小于栈顶元素存在时，就出栈并对出栈元素做计算，最后对栈里元素计算
 * @param {number[]} heights
 * @return {number}
 */
var largestRectangleArea = function(heights) {
  let n = heights.length;
  let i = 0;
  let max = 0;
  let stack = [];
  while (i < n) {
    while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {
      let top = heights[stack.pop()];
      max = Math.max(
        max,
        top * (i - (stack.length ? stack[stack.length - 1] : -1) - 1)
      );
    }
    stack.push(i++);
  }
  while (stack.length > 0) {
    max = Math.max(
      max,
      heights[stack.pop()] *
        (n - (stack.length ? stack[stack.length - 1] : -1) - 1)
    );
  }
  return max;
};

/**
  *下一个更大元素，还是一个栈但是这不再是一个递增的栈，因为是下一个更大的，每一个都要入栈，去留留给下一元素决定，倒叙遍历也是下一个更大的关键点
  *
  */
function nextGreaterElement(nums1, nums2) {
  const stack = [];
  const retMap = {};
  for (let i = nums2.length - 1; i >= 0; i--) {
    if (stack.length && stack[stack.length - 1] < nums2[i]) {
      stack.pop();
    }
    retMap[nums2[i]] = stack.length ? stack[stack.length - 1] : -1;
    stack.push(nums2[i]);
  }
  for (i = 0; i < nums1.length; i++) {
    nums1[i] = retMap[nums1[i]];
  }
  return nums1;
}


// 首先是转化符号为正负1，符号栈的构建也是关键
function calc(s) {
  let sign = 1;
  let ops = [1];
  let i = 0;
  let ret = 0;
  while (i < s.length) {
    if (s[i] === " ") {
      i++;
    } else if (s[i] === "+") {
      sign = ops[ops.length - 1];
      i++;
    } else if (s[i] === "-") {
      sign = -ops[ops.length - 1];
      i++;
    } else if (s[i] === "(") {
      ops.push(sign);
      i++;
    } else if (s[i] === ")") {
      ops.pop();
      i++;
    } else {
      let num = 0;
      while (s[i] !== " " && i < s.length && !isNaN(Number(s[i]))) {
        num = num * 10 + s[i].charCodeAt() - "0".charCodeAt();
        i++;
      }
      ret += sign * num;
    }
  }
  return ret;
}

/**
* #号删除,栈的方式
*/
var backspaceCompare = function(s, t) {
  let sStack = [];
  let tStack = [];
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "#") {
      sStack.pop();
    } else {
      sStack.push(s[i]);
    }
  }
  for (let t = 0; i < t.length; i++) {
    if (t[i] === "#") {
      tStack.pop();
    } else {
      tStack.push(t[i]);
    }
  }
  return s.join() === t.join();
};
// #号删除滚雪球方式，有区别的是这个删除要倒叙删除，因为是判断字符串是否相等,顺序逆序不用要
var backspaceCompare = function(s, t) {
  function removeD(str) {
    let newStr = "";
    let backCount = 0;
    for (let fast = str.length - 1; fast >= 0; fast--) {
      if (str[fast] === "#") {
        backCount++;
      } else {
        if (backCount === 0) {
          newStr += str[fast];
        } else {
          backCount--;
        }
      }
    }
    return newStr;
  }
  return removeD(s) === removeD(t);
};


/**
 * 接雨水，还是类似双指针解法，变形的双指针
 * @param {number[]} height
 * @return {number}
 */
var trap = function(height) {
  let left = 0;
  let right = height.length - 1;
  let leftMax = 0;
  let rightMax = 0;
  let res = 0;
  while (left < right) {
    if (height[left] < height[right]) {
      if (height[left] >= leftMax) {
        leftMax = height[left];
      } else {
        res += leftMax - height[left];
      }
      left++;
    } else {
      if (height[right] >= rightMax) {
        rightMax = height[right];
      } else {
        res += rightMax - height[right];
      }
      right--;
    }
  }
  return res;
};



/**
  * 双端队列，每次有新的进入需要删除老的小的，把自己放到队伍里再去掉队伍中又大又老的
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
 let ans = [];
  let i = 0;
  let stack = [];
  while (i < k) {
    while (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {
      stack.pop();
    }
    stack.push(i);
    i++;
  }
  ans[0] = nums[stack[0]];
  for (i = k; i < nums.length; i++) {
    while (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {
      stack.pop();
    }
    stack.push(i);
    while (stack[0] <= i - k) {
      stack.shift();
    }
    ans.push(nums[stack[0]]);
  }
  return ans;
};

// 有效括号，这就是典型的栈解法题目
var isValid = function(s) {
  let stack = [];
  for (let i = 0; i < s.length; i++) {
    const key = s[i];
    if (key === ")" && stack[stack.length - 1] === "(") {
      stack.pop();
    } else if (key === "]" && stack[stack.length - 1] === "[") {
      stack.pop();
    } else if (key === "}" && stack[stack.length - 1] === "{") {
      stack.pop();
    } else {
      stack.push(key);
    }
  }
  return !stack.length;
};
