# 基础
## 一

## 01

### java开发环境:  

java编译运行过程:-----------常见面试题 

1. 编译期:.java源文件，经过编译，生成.class字节码文件
2. 运行期:JVM加载.class并运行.class(0和1) 
   1. 特点:跨平台、一次编程到处使用 

名词解释:--------------------常见面试题 

1. JVM:java虚拟机 加载.class并运行.class 
2. JRE:java运行环境 除了包含JVM以外还包含了运行java程序所必须的环境	 JRE=JVM+java系统类库(小零件)-----小零件API时讲
3. JDK:java开发工具包 除了包含JRE以外还包含了开发java程序所必须的命令工具	 JDK=JRE+编译、运行等命令工具 说明: 
   1. 运行java程序的最小环境JRE 
   2. 开发java程序的最小环境JDK
   3. 配置环境变量:----------------------后面用到时再讲

## 02

### 变量:存数的 

1. 声明:-------相当于在银行开了个帐户 int a; //声明一个整型的变量，名为a int b,c,d; //声明三个整型的变量，名为b,c,d //int a; //编译错误，变量不能同名 

2. 初始化:-----相当于往帐户中存钱 int a = 250; //声明整型变量a并赋值为250 int b; //声明整型变量b b = 250; //给变量b赋值为250 

3. 使用:-------使用的是帐户里面的钱 

   1. 对变量的操作就是对它所存的那个数的操作

      ```JAVA
       	int a = 500;	 
      
      ​	int b = a+10; //取出a的值5，加10后，再赋值给变量b	 
      
      ​	System.out.println(b); //输出变量b的值15	
      System.out.println("b"); //输出b，双引号中的原样输出	 
      a = a+10; //取出a的值5，加10后，再赋值给a	 //在a本身基础之上增10	 		         
      System.out.println(a); //15 
      ```

      

   2. 变量在使用之前必须声明并初始化 

      ```JAVA
      System.out.println(m); //编译错误，变量m未声明	 
      
      int m;	 System.out.println(m); //编译错误，变量m未初始化 
      ```

      

4. 命名: 
   1. 只能包含字母、数字、_和$符，不能以数字开头 
   2. 严格区分大小写 
   3. 不能使用关键字 
   4. 允许中文命名，但不建议，建议"英文的见名知意"、"驼峰命名法"

### 八种基本数据类型:byte,short,int,long,float,double,boolean,char 

1. int:整型，4个字节，-21个多亿到21个多亿 
   1. 整数直接量默认为int类型，但不能超范围，若超范围则发生编译错误 
   2. 两个整数相除，结果还是整数，小数位无条件舍弃(不会四舍五入) 
   3. 整数运算时，若超出范围则发生溢出(溢出不是错误，但是需要避免) 

2. long:长整型，8个字节，很大很大很大 
   1. 长整型的直接量需在数字后加L或l 
   2. 运算时若有可能溢出，建议在第1个数字后加L 
3. double:浮点型，8个字节，很大很大很大 
   1. 浮点数直接量默认为double型，若想表示float需在数字后加F或f 
   2. double或float型数据参与运算时，有可能会发生舍入误差，精确场合不能使
   3. boolean:布尔型，1个字节 
   4. 只能取值为true或false 

4. char:字符型，2个字节 

   1. 采用Unicode字符集编码格式，一个字符对应一个码， 表现的形式为字符char，但本质上是码int(0到65535)	(ASCII码: 'a'--97 'A'--65 '0'--48) 
   2. 字符型直接量必须放在单引号中，并且只能有一个 
   3. 特殊符号需通过\来转义

5. 数据类型间的转换

   1. 数据类型从小到大依次为: byte--short--int--long--float--double char-- 
   2. 两种方式: 
      1. 自动/隐式类型转换:小类型到大类型 
      2. 强制类型转换:大类型到小类型 语法: (要转换成为的数据类型)变量 强转有可能溢出或丢失精度 

         		3. 两点规则:
          			1. 整数直接量可以直接赋值给byte,short,char，但不能超出范
          			2. byte,short,char型数据参与运算时，系统先将其自动转换为int再运算

## 03

### 运算符: 

算术:+,-,*,/,%,++,--* 

关系:>,<,>=,<=,==,!= boolean* 

逻辑:&&,||,! boolean* 

赋值:=,+=,-=,*=,/=,%= 

字符串连接:+ 

条件/三目: boolean?数1:数22.分支结构:基于条件执行某语句 

if结构: 1条路 

if...else结构: 2条路

## 04

### Scanner接收用户输入的数据:------背下来，不需要理解(面向对象第5天才能理解) 

在package下: import java.util.Scanner; 

在main中: Scanner scan = new Scanner(System.in); 

在第2步之下: 

```java
System.out.println("请输入年龄:"); 

int age = scan.nextInt(); 

System.out.println("请输入价格:"); 

double price = scan.nextDouble();
```

### 分支结构: 

1)if结构: 1条路 

2)if...else结构: 2条路 

3)if...else if结构: 多条路 

4)switch...case结构: 多条路 优点:效率高、结构清晰 缺点:只能对整数来判断相等 break:跳出switch

### 循环:反复多次执行一段相同或相似的代码

### 循环三要素: 

1)循环变量的初始化 

2)循环的条件(以循环变量为基础) 

3)循环变量的改变(向着循环的结束变) 循环变量:在整个循环过程中所反复改变的那个数

### 循环结构: 

1)while结构:先判断后执行，有可能一次都不执行 

2)do...while结构:先执行后判断，至少执行一次 要素1与要素3相同时，首选do...while

## 05

### 循环结构: 

for结构:应用率最高，与次数相关的

### 三种循环结构的选择规则: 

1)先看循环是否与次数相关: 

1.1)相关-------------------------------直接上for 

1.2)不相关，再看要素1与要素3是否相同: 

1.2.1)相同-------------------------直接上do...while	

1.2.2)不相同-----------------------直接上while

### break:跳出循环 continue:跳过循环体中剩余语句而进入下一次循环

### 嵌套循环: 

1)循环中套循环，一般多行多列时使用，外层控制行，内层控制列 

2)执行规则:外层循环走一次，内层循环走所有次 

3)建议:嵌套层数越少越好，能用一层就不用两层，能用两层就不用三层 若业务必须通过三层以上的循环来解决，说明你的设计有问题 

4)break只能跳出一层循环

### 数组: 

1)是一种数据类型(引用类型) 

2)相同数据类型元素的集合 

3)定义: int[] arr = new int[10]; 

4)初始化: 初始化数组中的元素 

```java
int[] arr = new int[4]; //0,0,0,0 

int[] arr = {1,4,5,7}; //1,4,5,7 

int[] arr = new int[]{1,4,5,7}; //1,4,5,7 

int[] arr; arr = {1,4,5,7}; //编译错误，此方式只能声明同时初始化 

arr = new int[]{1,4,5,7}; //正确 
```



### 访问: 访问的是数组中的元素 

通过(数组名.length)可以获取数组的长度(元素的个数) int[] arr = new int[3];	 System.out.println(arr.length); //3 

通过下标/索引来访问数组中的元素 下标从0开始，最大到(数组的长度-1)	 

```java
int[] arr = new int[3];	 

arr[0] = 100; //给arr中的第1个元素赋值为100 

arr[1] = 200; //给arr中的第2个元素赋值为200	 

arr[2] = 300; //给arr中的第3个元素赋值为300	 

//arr[3] = 400; //运行时发生---数组下标越界异常	 		

System.out.println(arr[arr.length-1]); //输出arr中最后一个元素的值 
```

遍历: 

```java
int[] arr = new int[10]; 

for(int i=0;i<arr.length;i++){ 

//遍历arr数组 arr[i] = 100; 

//给arr中每个元素赋值为100	

System.out.println(arr[i]); //输出每个元素的值

 }
```

## 06

### 数组: 

数组的复制: 

```java
System.arraycopy(a,1,b,0,4);
int[] b = Arrays.copyOf(a,6); 

a = Arrays.copyOf(a,a.length+1); 
```

8)数组的排序: 

```java
Arrays.sort(arr); //对arr进行升序排列
```

### 方法: 函数、过程 

封装一段特定的业务逻辑功能 

尽可能独立，只干一件事 

可以被反复调用多次 

减少代码重复，有利于代码维护

### 方法的定义: 五要素 修饰词 返回值类型 方法名(参数列表){ 方法体 }

### 方法的调用: 

无返回值: 方法名(有参传参); 

有返回值: 数据类型 变量 = 方法名(有参传参);

### return: 

## 二

## 01

### 什么是类？什么是对象？ 

1)现实生活中是由很多很多对象组成的，基于对象抽出了类 

2)对象:软件中真实存在的单个个体/东西 类:模板/模子/类型，代表一类个体 

3)类是对象的模板，对象是类的具体的实例 

4)类中可以包含: 

1. 对象所共有的属性/特征-------------成员变量 
2. 对象所共有的行为/动作-------------方法 

5)一个类可以创建多个对象2.如何创建类？如何创建对象？如何访问成员？

## 02

### 方法的签名:方法名+参数列表

### 方法的重载(Overload):------调用起来方便、不需要记住很多的方法名 

1. 发生在同一类中，方法名相同，参数列表不同，方法体不同 
2. 编译器在编译时会根据方法的签名自动绑定调用的方法

### 构造方法:------------代码复用(给成员变量赋值的代码复用) 

1. 给成员变量赋初值 
2. 与类同名、没有返回值类型(连void没有)
3. 在创建(new)对象时被自动调用 
4. 若自己不写构造方法，则编译器默认提供一个无参构造方法 若自己写了构造方法，则不再默认提供 
5. 构造方法可以重载

### this:指代当前对象，哪个对象调用方法它指的就是哪个对象 只能用在方法中，方法中访问成员变量之前默认有个this. this的用法: 

1)this.成员变量名--------访问成员变量 注意:当成员变量与局部变量同名时，访问成员变量的this不能省略 

2)this.方法名()----------调用方法(一般不用) 

3)this()-----------------调用构造方法(一般不用)

### null:表示空，没有指向任何对象 若引用的值为null，则该引用不能进行任何点操作了 若操作则发生NullPointerException空指针异常

## 03

### 引用类型数组: 

```java
Student[] stus = new Student[3]; 
stus[0] = new Student("zs",25,"LF");
stus[1] = new Student("ls",26,"JMS"); 
stus[2] = new Student("ww",24,"SD");
stus[0].age = 28; //修改第1个学生的年龄为28
System.out.println(stus[1].name); //输出第2个学生的名字
stus[2].sayHi(); //第3个学生跟大家问好
for(int i=0;i<stus.length;i++){ //遍历所有学生
  System.out.println(stus[i].name); //输出每个学生的名字
  stus[i].sayHi(); //每个学生跟大家问好
}
```

## 继承: 

1)作用:代码复用 

2)通过extends来实现继承 

3)超类:所有派生类所共有的属性和行为 派生类:派生类所特有的属性和行为 

4)派生类继承超类后，派生类具有:派生类的+超类的 

5)一个超类可以有多个派生类 一个派生类只能有一个超类-------单一继承 

6)继承具有传递性 

7)java规定:构造派生类之前必须先构造超类 ----在派生类的构造中若没有调用超类构造，则默认super()调用超类无参构造 ----在派生类的构造中若调用了超类构造，则不再默认提供 注意:super()调用超类构造，必须位于派生类构造的第一行

### super:指代当前对象的超类对象 super的用法: 

1)super.成员变量名-----------访问超类的成员变量 

2)super.方法名()-------------调用超类的方法-----------明天下午讲 

3)super()--------------------调用超类的构造方法

## 04

### 向上造型: 

1)超类型的引用指向派生类的对象 

2)能点出来什么，看引用的类型---------这是规定，记住就可以了

### 方法的重写(Override):重新写、覆盖 

1)发生在父子类中，方法名称相同，参数列表相同，方法体不同 

2)重写方法被调用时，看对象的类型-----这是规定，记住就可以了 

3)重写需遵循"两同两小一大"原则-----了解，一般都是一模一样的 

两同: 

1. 方法名称相同	
2. 参数列表相同 

两小: 

1. 派生类方法的返回值类型小于或等于超类方法的	
   1. void时，必须相同	
   2. 基本类型时，必须相同
   3. 引用类型时，小于或等于	
   4. 派生类方法抛出的异常小于或等于超类方法的-------API异常时讲 

一大: 

1. 派生类方法的访问权限大于或等于超类方法的-------明天讲

### 重写与重载的区别:------常见面试题(回答时只需回答1.1和2.1即可) 

1)重写(Override): 

1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同 

1.2)遵循"运行期绑定"，看对象的类型来调用方法 

2)重载(Overload): 

2.1)发生在同一类中，方法名称相同，参数列表不同，方法体不同 

2.2)遵循"编译期绑定"，看参数/引用的类型来绑定调用方法

## 05

### package: 

1)作用:避免类的命名冲突 

2)同包中的类不能同名，类的全称:包名.类名 

3)包名可以有层次结构 

4)建议:包名所有字母都小写 

### import: 

1)同包中的类可以直接访问 不同包中的类不能直接访问，若想访问有如下两种方式: 

1.1)先import声明类再访问类-----建议 

1.2)类的全称-------------------太繁琐，不建议

### 访问控制修饰符:-----------保护数据的安全 

1)public:公开的，任何类 

2)private:私有的，本类 

3)protected:受保护的，本类、派生类、同包类 

4)默认的:什么也不写，本类、同包类 说明: 

1. 类的访问权限只能是public或默认的 
2. 类中成员的访问权限如上4种都可以

### final:最终的、不可改变的------单独应用几率低，了解即可 

1)修饰变量:变量不能被改变 

2)修饰方法:方法不能被重写 

3)修饰类:类不能被继承

### static:静态的 

1)静态变量: 

1.1)由static修饰 

1.2)属于类，存储在方法区中，只有一份

1.3)常常通过类名点来访问 

1.4)何时用:所有对象所共享的数据(图片、音频、视频等) 

2)静态方法: 

2.1)由static修饰 

2.2)属于类，存储在方法区中，只有一份 

2.3)常常通过类名点来访问 

2.4)静态方法中没有隐式this传递， 所以静态方法中不能直接访问实例成员 

2.5)何时用:方法的操作与对象无关 

3)静态块: 

3.1)由static修饰 

3.2)属于类的，在类被加载期间自动执行， 一个类只被加载一次，所以静态块也只执行一次 

3.3)何时用:初始化/加载静态资源(图片、音频、视频等)

## 06

### static final常量:应用率高 

1)必须声明同时初始化 

2)由类名点来访问，不能被改变 

3)建议:常量名建议所有字母都大写，多个单词用_分隔 

4)编译器在编译时将常量直接替换为具体的值，效率高 

5)何时用:数据永远不变，并且经常使用

### 抽象方法: 

1)由abstract修饰 

2)只有方法的定义，没有具体的实现(连{}都没有)

### 抽象类: 

1)由abstract修饰 

2)包含抽象方法的类必须是抽象类 

3)抽象类不能被实例化 

4)抽象类是需要被继承的，派生类:

1. 重写所有抽象方法---------变不完整为完整 
2. 也声明为抽象类-----------不常用 

5)抽象类的意义:

1. 封装派生类共有的属性和行为--------代码复用 
2. 为所有派生类提供统一的类型--------向上造型 
3. 可以包含抽象方法，为所有派生类提供统一的入口(造型之后能点出来) 派生类的具体实现不同，但入口是一致的

## 07

### 成员内部类:------应用率低，了解即可 

1)类中套类，外面的称为外部类，里面的称为内部类 

2)内部类通常只服务于外部类，对外不具备可见性 

3)内部类对象通常是在外部类中创建的 

4)内部类中可以直接访问外部类的成员(包括私有的) 内部类中有个隐式的引用指向了创建它的外部类对象 外部类名.this

### 匿名内部类:-------------优点:简化代码 

1)若想创建一个类(派生类)的对象，并且对象只创建一次， 此时该类不必命名，称为匿名内部类 

2)匿名内部类中不能修改外面的变量的值，因为该变量一定是final的

常见面试题:问:内部类有独立的.class吗?答:有

## 08

### 接口: 

1)是一种数据类型(引用类型) 

2)由interface定义 

3)只能包含常量和抽象方法 

4)接口不能被实例化 

5)接口是需要被实现/继承的，实现/派生类: 必须重写接口中的所有抽象方法 

6)一个类可以实现多个接口，用逗号分隔 若又继承又实现时，应先继承后实现 

7)接口可以继承接口

设计规则:

1)将所有派生类所共有的属性和行为，抽到超类中----------抽共性

2)派生类的行为都一样，设计为普通方法 派生类的行为都不一样，设计为抽象方法

3)将部分派生类所共有的属性和行为，抽到接口中 接口是对继承的单根性的扩展----------实现多继承

## 09

### 多态: 

1)意义: 

1.1)同一类型的引用，指向不同的对象时，有不同的实现 ----行为的多态:cut(),step(),getImage()... 

1.2)同一个对象，被造型为不同的类型时，有不同的功能 ----对象的多态:我,你,水..

2)向上造型/自动类型转换: 

2.1)超类型的引用指向派生类的对象 

2.2)能造型成为的数据类型有: 超类+所实现的接口 

2.3)能点出来什么，看引用的类型 

3)强制类型转换，成功的条件只有如下两种: 

3.1)引用所指向的对象，就是该类型 

3.2)引用所指向的对象，实现了该接口或继承了该类 

4)强转时若不符合如上条件，则发生ClassCastException类型转换异常 建议:强转之前先通过instanceof来判断引用的对象是否是该类型

## 10

### 内存管理:由JVM来管理 

1)堆: 

1.1)存储new出来的对象(包括实例变量) 

1.2)垃圾:没有任何引用所指向的对象 垃圾回收器(GC)不定时到内存中清扫垃圾，	回收过程是透明的(看不到的)，不一定一发现垃圾就立刻回收，	通过调用System.gc()建议虚拟机尽快调度GC来回收垃圾 

1.3)内存泄漏:不再使用的内存还没有被及时的回收，严重的会导致系统的崩溃 建议:不再使用的内存应及时将引用设置为null 

1.4)实例变量的生命周期: 创建对象时存储在堆中，对象被回收时一并被回收 

2)栈: 

2.1)存储正在调用方法中的所有局部变量(包括方法的参数) 

2.2)调用方法时，会在栈中为该方法分配一块对应的栈帧， 栈帧中存储方法中的局部变量(包括方法的参数)，	方法调用结束时，栈帧自动被清除，局部变量一并被清除 

2.3)局部变量的生命周期: 调用方法时存储在栈中，方法调用结束时与栈帧一并被清除 

3)方法区: 

3.1)存储.class字节码文件(包括静态变量、方法) 

3.2)方法只有一份，通过this来区分具体的调用对象

### 面向对象三大特征:----------常见面试题(你对面向对象的理解)

1.封装: 

1)类:封装的是对象的属性和行为 

2)方法:封装的是具体的业务逻辑功能实现 

3)访问控制修饰符:封装的是具体的访问权限

2.继承: 

1)作用:代码复用 

2)超类:所有派生类所共有的属性和行为 接口:部分派生类所共有的属性和行为 派生类:派生类所特有的属性和行为 

3)单一继承、多接口实现，具有传递性

3.多态: 

1)行为的多态:所有抽象方法都是多态的 对象的多态:所有对象都是多态的 

2)向上造型、强制类型转换、instanceof 

3)多态的表现形式: 

3.1)行为多态，通过方法的重写来表现的 

3.2)对象多态，通过向上造型来表现的


