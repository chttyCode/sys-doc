# browser

- 了解一些 browser 知识,以点串线，成网，站在更高的维度去审视问题
- 浏览器演进路线
  - JS 执行速度
    - 不断修订更新语言本身
    - webAssembly 编译脚本
  - 业务发展规模
    - webComponent 模块化
    - 框架模块化
  - 渲染效率
    - 布局方案
    - 渲染方案

## 宏观角度浏览器

### chrome 架构

- 优化 web 性能需要了解浏览器的网络请求、页面渲染、js 执行以及 web 安全，学习浏览器架构可以将这些知识串联起来，以点串线成网

- 浏览器架构的基础知识
  - 线程 vs 进程
    - 进程是软件运行的实例，是系统分配内存的最小单位，负责向系统申请存放运行时代码、保存运行变量的内存空间
    - 线程依赖进程，不能单独存在
    - 特点
      - 进程中任一线程执行出错，都会导致整个进程的崩溃
      - 线程之间共享进程中的数据
      - 进程关闭后系统会回收进程所占内存
      - 进程之间的内容相互隔离
  - 并发
    - 采用多线程同时执行
- 浏览器的演进
  - 单进程
    - 早期浏览器多线程运行在单一浏览器进程，包括插件线程、网络线程、渲染线程(处理 js 执行、html、css 渲染)
    - 问题：
      - 不稳定
        - 某一线程崩溃会引起浏览器进程崩溃
      - 不流畅
        - js 长任务执行会引起页面卡顿
      - 不安全
        - 浏览器能够获取系统资源、插件脚本也能够获取系统资源
  - 多进程
    - 插件进程、渲染进程、浏览器进程
      - 浏览器主进程：负责页面呈现、IPC 通信管理(主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。)
      - 渲染进程：浏览器会为每一个 tab 创建一个新的渲染进程，负责 js 执行、页面渲染
      - 插件进程：负责插件运行
      - GPU 进程：最初的目的是进行 3D 渲染，随后的页面、chromeUI 都采用 GPU
    - 解决了
      - 进程相互隔离，页面或插件崩溃不会影响浏览器主进程
      - 多进程可以采用沙箱隔离的方式，避免安全问题
      - 每个页面创建一个渲染进程，解决了不流畅的问题
    - 问题
      - 多进程带了庞大的资源开销
      - 架构更加复杂
  - 面向服务架构
    - 采用面向服务架构的思想、将以服务的方式重构以前的模块
      - 插件进程
      - 渲染进程
      - 基础服务进程
        - 网络进程
        - GPU 进程
        - UI 进程
    - 在低内存的设备上会合并基础服务到浏览器进程，降低内存开销

### TCP 协议

- 网络加载对 Web 性能的影响是其中最重要的因素，如果优化网络加载，就需要对网络知识有充分的了解，熟悉网络可以提升优化性能、解决问题的能力
- 数据信息在网络中是以包的形式传送的
- 一个数据包在网络中如何传递的，就需要有一定的规则
  - IP 协议： 规则负责将数据包送达指定的主机
  - UDP 协议：用户数据包协议负责将数据送达目的主机的特定程序
  - 网络传输分层
    - 应用层
      - 程序应用实例，每一个程序都会监听一个端口
    - 传输层
      - 给数据包添加目的主机的应用端口号
    - 网络层
      - 在数据包上附加 IP 信息，ip 负责路由寻址，将数据包送达指定 ip 主机
    - 数据链路层
      - 通过物理连接传输数据包
  - 存在的问题
    - 一个完整的数据会被拆分成 n 个数据包进行传输，传输的过程中，数据包可能会通过不同的路由进行传输，那样数据包送达的时间、数量无法得到保障、无法确认数据的完整性
  - 满足不了对数据完整性要求比较高的业务
    - TCP 协议
      - 生命周期
        - 建立连接
          - 客户端会发送请求通信
          - 服务端会回复确认信息 ACK 和请求通信
          - 客户端收到后会回复服务端 ACK
        - 传输数据
          - 该阶段接受方需要对每个数据包进行确认、对接收到的数据包根据 TCP 头中的序号进行排序
        - 断开连接
          - 客户端发送断开请求
          - 服务端发送 ACK,即客户端可以断开请求，此时服务端可能还存在要传输的信息，即无法发送断开请求
          - 服务端在发送完数据后，发送断开请求
          - 客户端接收到请求，发送 ACK,即断开连接
      - 解决 UDP 存在的问题
        - 对数据丢包，提供了重传机制
          - 传输过程中，接收方在接到数据包后需发送确认信息，如果发送方在规定时间内没有收到接受方的确认信息，则视为丢包会触发重传机制
        - 对数据完整性，引入数据包排序机制
          - TCP 协议在传输层除了提供端口号、还提供了用于排序的序号

### http 请求

- http 是基于 tcp 的应用层协议，主要用于客户端于服务器的通信，如果说 tcp 是保证了一个数据包端到端的传输，那么 http 就是负责页面级的传输，超文本传输控制协议
- 导航流程
  - 输入 URL
  - 构建请求
    - 根据 http 协议构建请求起始行
    - 构建请求头
    - 构建请求体
  - tcp 协议附加 Ip&应用端口号
    - 查询 DNS,查询本机缓存，获取对应的 IP
    - 端口号
      - http 默认 80
      - https 默认 445
  - 建立连接
    - chrome 对同一域名的请求有限制，如果当前请求数大于 6，则进入排队等待
    - 通过三次握手建立连接
  - 客户端发送请求信息
    - 判断是否有缓存可用，如果缓存有效则拦截请求直接返回缓存信息
  - 服务端发送信息
  - 客户端接收信息
    - 请求如果是 302,即临时重定向，会根据响应头的 LOCATION 字段重定向
  - 断开连接
    - 如果请求开启 keep-alive，即长连接，会雇佣 TCP 连接
    - 四次挥手断开连接
- http 为无状态连接
  - 服务端在响应头中设置 cookie
  - 客户端再下一次请求同域名时会带上 cookie
  - 服务端校验所携带的 cookie 是否为已登录
- 为什么第二次打开相同页面会变快
  - 第一次访问后会有 DNS 域名缓存
  - 第一次访问后会有静态资源缓存


### 导航流程

### 渲染流程
