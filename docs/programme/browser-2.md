# Js 的执行机制

JS 是不是顺序执行的，如果是那又如何解释下面这段代码

```js
showName();
console.log(myname);
var myname = "极客时间";
function showName() {
  console.log("函数showName被执行");
}

function food(obj) {
  let a = 1;
  with (obj) {
    a = 3;
  }
  console.log("fn,a", a);
}
var o1 = {
  a: 2,
};
var o2 = {
  b: 2,
};
food(o1);
console.log(o1.a);

food(o2);
console.log(o2.a);
console.log(a);
```

接下来我会对其背后的运行的规则，进行脉络的学习

- 作用域

  任何一种编程语言最基本的功能就是能够存储变量当中的值，并且能够对其进行访问修改，试想，如果程序没有了存储访问变量的功能，程序就只能执行一些简单的任务。随之而来的问题就是，如何对一个变量进行存储访问控制，这就需要一套完整的访问控制规则，即作用域的概念

- 编译、作用域、引擎

  一段代码的执行过程，一般都会经历编译、执行，虽说 JS 是解释型语言，但是其依然有编译的过程，只是其编译过程发生在执行前的几微秒（甚至更短），JS 引擎用了多种方法（如 JIT）来保证性能

- 块级作用域的替代方案

  try/catch：性能写法确实很糟糕、但自从 TC39 支持在 ES6 的转换中适用 try/catch 后，chrome 团队已经对 try/catch 的性能进行了优化

  IIFE: 如果将一段代码中的任意一部分拿出来用函数进行包裹、会改变这段代码的含义，其中的 this、return、break、continue 都会发生变化，所以 IIFE 不是一个普适的方案、只适合某些情况下手动操作

- 声明提前

  以前的版本中没有块级的概念、函数只有在调用执行的时候才会进行编译，所以你那是的变量对当前执行环境栈来说都是可见可访问的，为了有效的访问，变将变量声明在编译阶段进行提前

- 执行上下文

  就目前的 JS 来说，执行过程中有 3 个场景会创建自己的上下文，即函数、全局、eval,执行上下文相对作用域来说是一个作用域的集合，其中包括词法作用域、动态作用域(this)

- 动态作用域 vs 词法作用域

  词法作用域较为好理解，即代由代码书写时的位置决定，动态作用域确实由调用执行的位置决定，JS 并没有动态作用域一说，但其实现的 this，又与动态作用域是分类似、this 是与词法作用域共存的两套规则

  ```js
  // 场景1，词法作用域
  function(){
      console.log(a)
  }
  function bar(){
      let a = 3;
      foo()
  }
  let a = 2
  bar()
  ```

  ```js
  // 类动态作用域，this
  let foo = {
    a: 3,
    bar() {
      console.log(a);
    },
  };
  let a = 2;
  foo.bar(); // 2 要访问得到3，怎么处理
  ```

- 作用域嵌套、作用域链

  作用域是由词法环境决定的，即代码书写时的嵌套位置决定运行时变量查找的路径

- 闭包

  无法释放的执行上下文，因为 JS 是自动进行垃圾回收的，由于当前执行环境中的某些变量被其他执行环境中的变量引用，而无法进行自我回收。
