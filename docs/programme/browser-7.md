# 安全

浏览器安全可以分为三大块——Web 页面安全、浏览器网络安全和浏览器系统安全

## 页面安全

Web 世界会是开放的，但我们需要隐私保护

### 同源策略（Same-origin policy）

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源

同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信。主要表现在 DOM、Web 数据和网络这三个层面。

#### DOM

同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。

#### 数据层

同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据

#### 网络

同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点

### 安全和便利性的权衡

隔绝是安全的，但是开发又是必须的，业务中肯定会有跨站点访问的场景，浏览器安全策略中提供的平衡技术

#### 第一步资源放开

同源策略要求页面所有资源都来自一个源，第一个平衡就是允许页面嵌入第三方资源

带来的挑战是页面被劫持注入第三方脚本，即 xss 攻击

浏览器的弥补策略是内容安全策略，即 CSP,其核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码

##### 内容安全策略( CSP )

主要目标是减少和报告 XSS 攻击

你需要配置你的网络服务器返回 Content-Security-Policy HTTP 头部，除此之外, <meta> 元素也可以被用来配置该策略

配置策略

1.  default-src 限制域脚本加载
2.  script-src (en-US) 指令来防止内联脚本运行, 并杜绝 eval()的使用
3.  style-src (en-US) 指令去限制来自一个 \<style> 元素或者 style 属性的內联样式
4.  img-src、media-src 限制音频或视频

#### 跨域资源共享和跨文档消息机制

不同站点无法进行跨站请求、无法操作 DOM，浏览器的平衡操作是提供跨域资源共享（CORS）、跨文档消息机制

##### 跨源资源共享（CORS）

服务器允许跨域而来的请求，CORS 请求前会发送预检请求，该请求主要是检测目标服务器是否支持跨域访问，请求头中会有有 HTTP 方法和真实请求中会用到的头。

出于安全性，有 HTTP 方法和真实请求中会用到的头。脚本内禁止 XMLHttpRequest 和 Fetch API 发起跨域请求

###### 使用场景：

1. 由 XMLHttpRequest 或 Fetch APIs 发起的跨源 HTTP 请求。
2. Web 字体 (CSS 中通过 @font-face 使用跨源字体资源)
3. WebGL 贴图
4. 使用 drawImage 将 Images/video 画面绘制到 canvas。
5. 来自图像的 CSS 图形

###### 预检请求：

OPTIONS 方法发起一个预检请求到服务器，主要目的就是确认目标服务器是否允许跨域访问，同样服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证 相关数据）需要主动设置表示标识，默认不带

###### 带来的问题 XSS 攻击，又称为“跨站脚本攻击”

XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”，主要表现为在 html 注入恶意脚本

恶意脚本可做的事

1. 可以窃取 Cookie 信息
2. 可以监听用户行为
3. 可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
4. 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。

恶意脚本注入的方式

1. 存储型 XSS 攻击
   1. 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
   2. 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
   3. 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。
2. 反射型 XSS 攻击
   1. 用户发送恶意代码
   2. 服务器又恶意代码返回
   3. Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方
3. 基于 DOM 的 XSS 攻击
   1. 通过网络劫持、WiFi 路由器劫持的，有通过本地恶意软件来劫持的修改 dom
   2. 就是在传输或者用户使用过程中修改 dom

防守：

1. 服务器对输入脚本进行过滤或转码

2) 充分利用 CSP，严格的 CSP 可以有效地防范 XSS 攻击
   1. 限制其他域的脚本加载，即使插入浏览器也无法加载
   2. 禁止向第三方域提交数据，这样用户数据也不会外泄；
   3. 禁止执行内联脚本和未授权的脚本；
   4. 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题
3) 使用 HttpOnly 属性

###### 带来的 CSRF 攻击，又称为“跨站请求伪造”

CSRF 英文全称是 Cross-site request forgery，主要表现为黑客利用了用户的登录状态，发起跨站请求。

攻击方式：

前提是系统提供某一功能的接口，例如某网站提供转账接口

```js
//localhost:3000/sendcoin
// 参数
// 目标用户
user;
// 目标金额
number;
```

1. 引诱用户点击黑客页面，在黑客页面构建 get、post 的自动请求
2. 引诱用户点击黑客页面的相应链接，通过点击链接发起求情

与 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。

分析：

csrf 攻击的必要条件

1. 目标站点一定要有 CSRF 漏洞，即关键点是要能找到服务器的漏洞
2. 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态
3. 需要用户打开一个第三方站点，可以是黑客的站点

与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的

防守：

1. 充分利用好 Cookie 的 SameSite 属性
   就是要同源站点携带 cookie，非同源站点禁止携带,Cookie 中的 SameSite 属性正是为了解决这个问题的
   SameSites 属性值：
   1. Strict 最为严格，完全禁止非同源 cookie 携带
   2. Lax 相对宽松一点，Get ，链接打开、get 表单会携带 Cookie，img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie
   3. None，在任何情况下都会发送 Cookie 数据
2. 验证请求的来源站点
   就是服务器端通过 HTTP 请求头中的 Referer 和 Origin 属性验证请求来源的站点

   1. Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，，但是有一些场景是不适合将来源 URL 暴露给服务器的
   2. Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，

   服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值

3. CSRF Token
   1. 在浏览器向服务器发起请求时，服务器生成一个 CSRF Token，然后将该字符串植入到返回的页面中
   2. 在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。

##### 跨文档消息机制(window.postMessage)

适用于两个页面的端口、协议、 Document.domain 相同的安全通信
