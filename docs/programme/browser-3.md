# V8 工作原理

## 数据存储形式

- 虽然 Js 不需要手动管理内存，但打造高性能 web 应用还是需要了解 JS 的数据是如果存储的
- JS 是弱类型、动态语言
  - 弱类型
    - 定义变量时无需定义类型
  - 动态语言
    - 运行是可以改变变量类型
- JS 的有八种变量类型
  | 类型 | 描述 |
  | ---- | ---- |
  | Boolean | 只有 true 和 false |
  | Null | 只有一个值 null |
  | Undefined | 没有被赋值的变量 |
  | Number | 基于 IEEE754 标准的双精度 64 位二进制值 |
  | BigInt | 新类型，表示任意精度整数 |
  | String | 字符串，不可更改 |
  | Symbol | 符合类型，通常被用作 Object 的 key |
  | Object | 属性的集合 |

  - typeof null 是 Object，主要为了兼容，一直没修复
  - JS 中一切皆对象
  - 8 种类型种分为 7 种基本类型、1 种引用类型
    - 基本类型是值拷贝
    - 引用类型是地址拷贝

- 存储空间分为三种
  - 代码空间
    - 存放可执行代码
  - 栈空间
    - 存储执行上下文
  - 堆空间
    - 存储大块数据即 Object 类型
  - 栈空间 vs 堆空间
    - 栈空间执行上下文需要频繁切换，所以内存空间大小有限
    - 为了切换提高切换性能，上下文中只存放基本类型&引用类型的地址
    - 堆空间用来存放大块数据
      - 缺点
        - 分配回收内存需要一定时间

## 垃圾数据回收

- 清楚了内存分配的方式，对使用后的垃圾数据怎么处理同样重要，
- JS 的产生的垃圾数据由垃圾回收处理器来释放
- 栈中数据的回收
  - 栈中数据通过 ESP 指针来表示
  - 出栈是指 ESP 的指针下移，当前上下文会被无效内存，会被后续入栈上下问覆盖
- 堆中数据的回收
  - 需要垃圾回收器回收
  - 首先了解一下代际假说
    - 代际假说
      - 大部分对象在内存中存活的时都很短、简单来说就是对象一经分配很快就变得不可访问
      - 不死的对象活得更久
  - 根据代际假说，v8 采用分代收集，即新生代、老生代，新生代中存放生存时间短的对象、老生代存放生存时间长的对象
    - 新生代
      - 通常内存在 1-8M 之间
    - 老生代
      - 通常内存空间比较大
  - 垃圾清理流程
    - 标记：遍历内存空间，到执行栈中查找是否有引用该内存的变量
    - 回收：回收非活动对象
    - 整理：频繁的内存回收会造成大量的内存碎片，需要进行内存整理
    - 新生代回收
      - 采用 Scavenge 算法，把新生代划分会对象区和空闲区
      - 新加入的对象都加入到对象区，在对象区快被写满时执行一次清理
      - 清理阶段
        - 标记
        - 将对象区中存活的对象复制到空闲区
        - 复制完成后将空闲区和对象区进行角色翻转
      - 存在的问题
        - 新生代垃圾回收通过复制翻转的方式进行，为了执行效率，内存空间一般比较小很容易被写满
        - 解决方式
          - 对象晋级策略
            - 经过 2 次垃圾回收依然存活的对象会被移动到老生代中
    - 老生代回收
      - 除了新生代晋级的对象、一些大对象也会被直接分配到老生代中
      - 老生代的数据一般比较大，内存空间也比较大，不适合 Scavenge 算法
      - 老生代采用标记整理的算法进行垃圾回收
        - 过程和标记清楚一样，也需要标记，不过不再是直接清除
        - 标记后让所有存活的对象向一端移动
        - 清理掉边界以外的对象
      - 存在的问题
        - js 在主线程执行，一旦执行垃圾回收，会暂停脚本执行，造成全停顿现象
        - 解决方式
          - 增量标记清除、将清理任务拆分为很多个子任务，穿插执行

## 编译器&解释器

- 已经了解了 javascript 的执行，存储、和垃圾回收，那我们编写的高级语言代码又是如何被 v8 执行的呢？
  - 编译器(Compiler)
    - 直接将高级代码编译成二进制文件
  - 解释器(Interpreter)
    - 每次运行时都需要进行动态解释并执行
  - 抽象语法树(AST)
    - 代码的结构性描述
  - 字节码(ByteCode)
    - 基于抽象语法树与二进制文件的中间产物
  - 即时编译(JIT)
    - 字节码配合解释器和编译器的技术
  - v8 如何执行 javascript
    > v8 的执行过程中即有解释器又有编辑器
    - 生成抽象语法树（AST）和执行上下文
      > 将源代码转换为抽象语法树，并生成执行上下文
      - 生成 AST 需要经过两个阶段
        - 第一阶段是分词（tokenize），又称为词法分析
          - 将代码按 token 进行拆解
        - 第二阶段是解析（parse），又称为语法分析
          - 将 token 按语法规则转为 AST
      - 有了 AST，v8 会生成该段代码的执行上下文
    - 生成字节码
      > 有了 AST、上下文，解释器会根据 AST 生成字节码，并解释执行
      > 其实一开始 v8 并没有生成字节码，而是直接将 AST 转为机器码，因为其执行效率高，但是机器码较字节码更占内存，为解决内存占用的问题，引入了字节码
      - 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行
    - 执行代码
      > 生成字节码之后，接下来就要进入执行阶段了
      - 解释器会追行解释执行代码，对执行过程中的热点代码会进行标注识别为热点代码
      - 对热点代码会启用编译器进行编译，编译成机器码，提升执行效率
- javascript 性能优化
  - 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
  - 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
  - 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。
