# V8 工作原理

## 数据存储形式

- 虽然 Js 不需要手动管理内存，但打造高性能 web 应用还是需要了解 JS 的数据是如果存储的
- JS 是弱类型、动态语言
  - 弱类型
    - 定义变量时无需定义类型
  - 动态语言
    - 运行是可以改变变量类型
- JS 的有八种变量类型
  | 类型 | 描述 |
  | ---- | ---- |
  | Boolean | 只有 true 和 false |
  | Null | 只有一个值 null |
  | Undefined | 没有被赋值的变量 |
  | Number | 基于 IEEE754 标准的双精度 64 位二进制值 |
  | BigInt | 新类型，表示任意精度整数 |
  | String | 字符串，不可更改 |
  | Symbol | 符合类型，通常被用作 Object 的 key |
  | Object | 属性的集合 |

  - typeof null 是 Object，主要为了兼容，一直没修复
  - JS 中一切皆对象
  - 8 种类型种分为 7 种基本类型、1 种引用类型
    - 基本类型是值拷贝
    - 引用类型是地址拷贝

- 存储空间分为三种
  - 代码空间
    - 存放可执行代码
  - 栈空间
    - 存储执行上下文
  - 堆空间
    - 存储大块数据即 Object 类型
  - 栈空间 vs 堆空间
    - 栈空间执行上下文需要频繁切换，所以内存空间大小有限
    - 为了切换提高切换性能，上下文中只存放基本类型&引用类型的地址
    - 堆空间用来存放大块数据
      - 缺点
        - 分配回收内存需要一定时间

## 垃圾数据回收

- 清楚了内存分配的方式，对使用后的垃圾数据怎么处理同样重要，
- JS 的产生的垃圾数据由垃圾回收处理器来释放
- 栈中数据的回收
  - 栈中数据通过 ESP 指针来表示
  - 出栈是指 ESP 的指针下移，当前上下文会被无效内存，会被后续入栈上下问覆盖
- 堆中数据的回收
  - 需要垃圾回收器回收
  - 首先了解一下代际假说
    - 代际假说
      - 大部分对象在内存中存活的时都很短、简单来说就是对象一经分配很快就变得不可访问
      - 不死的对象活得更久
  - 根据代际假说，v8 采用分代收集，即新生代、老生代，新生代中存放生存时间短的对象、老生代存放生存时间长的对象
    - 新生代
      - 通常内存在 1-8M 之间
    - 老生代
      - 通常内存空间比较大
  - 垃圾清理流程
    - 标记：遍历内存空间，到执行栈中查找是否有引用该内存的变量
    - 回收：回收非活动对象
    - 整理：频繁的内存回收会造成大量的内存碎片，需要进行内存整理
    - 新生代回收
      - 采用 Scavenge 算法，把新生代划分会对象区和空闲区
      - 新加入的对象都加入到对象区，在对象区快被写满时执行一次清理
      - 清理阶段
        - 标记
        - 将对象区中存活的对象复制到空闲区
        - 复制完成后将空闲区和对象区进行角色翻转
      - 存在的问题
        - 新生代垃圾回收通过复制翻转的方式进行，为了执行效率，内存空间一般比较小很容易被写满
        - 解决方式
          - 对象晋级策略
            - 经过 2 次垃圾回收依然存活的对象会被移动到老生代中
    - 老生代回收
      - 除了新生代晋级的对象、一些大对象也会被直接分配到老生代中
      - 老生代的数据一般比较大，内存空间也比较大，不适合 Scavenge 算法
      - 老生代采用标记整理的算法进行垃圾回收
        - 过程和标记清楚一样，也需要标记，不过不再是直接清除
        - 标记后让所有存活的对象向一端移动
        - 清理掉边界以外的对象
      - 存在的问题
        - js 在主线程执行，一旦执行垃圾回收，会暂停脚本执行，造成全停顿现象
        - 解决方式
          - 增量标记清除、将清理任务拆分为很多个子任务，穿插执行

## 编译器&解释器
