# 循环系统

- 页面循环系统
  - 渲染进程的主线程
    - 主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件
    - 存在的问题
      - 单一主线程只能处理预安排的任务
      - 如何处理过程中的任务
  - 事件+循环
    - 循环
      - 在线程语句最后添加了一个 for 循环语句，线程会一直循环执行
    - 事件
      - 线程运行过程中可以监听用户行为等事件，激活循环处理任务
    - 存在的问题
      - 这种监听+循环处理只能处理自身执行过程中产生的任务，如何处理其他线程、进程的问题
  - 队列
    - 事件+循环只能执行自身执行过程中产生的任务,需要实现一个收集任务的数据结构，而这个结构满足先进显然是队列这种数据结构的特点
    - 所以无论是线程、进程还是执行过程中产生的任务都加入到任务队列中，待主线程循环执行
  - 事件类型
    - 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器
    - JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画
  - 这种单线程任务队列的形式存在的问题
    - 无法处理高优先级的任务
      - eg
        - js 监听 dom 改变，采用同步的方式会影响效率，采用异步的方式存在实时性问题
        - 解决方案是实现一个微任务队列
    - 如何解决但任务执行事件过长
- setTimeout
  - 如何去执行一个指定时间触发的任务
  - 在已有的任务队列是满足不了需求的，所以设计一个新的队列，该队列同样满足先进先出，只是队列存储的是一个 MAP 类型的任务，该 map 对象有时间信息，用于判断是否执行该任务
  - 踩坑指南
    - 当前任务执行会影响定时器任务的执行
    - tab 不是激活状态时，setTimeout 的执行时间是 >=1000ms
    - 嵌套达到 5 层的定时器嵌套调用，会被浏览器认定为存在性能问题，其执行的时间间隔>=4ms，动画慎用
    - 时间间隔不能大于 32bit 最大存放的数字 2147483647 毫秒，否则会是立即执行的效果
    - 使用 setTimeout 设置的回调函数中的 this 不符合直觉
- XMLRequest
  - 踩坑指南
    - 存在跨域问题
    - HTTPS 混合内容的问题
- 微任务与宏任务
  - 事件循环机制[WHATWG 规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)
  - 监听 dom 变化
    - 第一版
      - 实时回调
      - 存在性能问题
    - 第二版
      - 批量回调
      - 存在操作 dom 实时性问题
    - 第三版
      - 在宏任务队列之外在维护一个队列，即微任务队列
      - 每一个宏任务都会维护一个微任务队列，在宏任务执行完推出时会检测执行微任务队列
      - 即保证了实时性、又解决了性能问题
- promise
  - 异步编程存在的问题
    - 嵌套调用
    - 多错误处理
  - promise 方案
    - 实现延时任务
    - 值穿透
  - 存在的问题
    - 包含了大量的 then 函数
- async/await

  - 在不阻塞的情况下，使用同步的方式访问异步资源，使得代码逻辑更加清晰
  - javascript 是如何实现 async&await 的

    - 生成器 VS 协程
      - 生产器
        - 带星号的函数，可以暂停执行、恢复执行
        - 执行过程
          - 遇到 yield,将 yield 后面的内容返回给外部，并暂停该函数的执行
          - 外部可以通过 next 恢复函数执行
      - 协程
        - 比线程更轻量级的存在，一个线程可以存在多个协程，但线程只能同时执行一个协程，正如一个进程可以有多个线程一般
          - 区别在于协程可以由用户切换，不会像线程切换产生资源消耗
        - 执行过程
          - 调用生产器创建协程，创建时并不执行
          - 通过调用 next，执行协程
          - 执行过程中可以通过 yield 暂停协程的执行，将 yield 后的信息返回给父协程
          - 执行过程中如果遇到 return 那么 js 引擎会退出协程执行将 return 内容返回父协程
        - 特点
          - gen 协程和父协程是在主线程上交互执行的，并不是并发执行
          - 当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。
    - async/await Promise 和生成器的语法糖
    - async
      - 异步执行和隐式返回 Promise
    - await
      - 会默认创建一个 Promise 对象
      - 暂停当前协程执行，将 promise 返回给父协程
      - 父协程调用 promise\_.then 来监控 promise 状态的改变
      - 该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。

    通过 CO 的栗子来看，async/await 的语法糖

  ```js
  function CO(gen) {
    return new Promise((resolve, reject) => {
      const it = gen();
      function next(it, value) {
        const { done, value: v } = it.next(value);
        if (done) {
          return resolve(v);
        }
        Promise.resolve(v).then((res) => {
          next(it, res);
        });
      }
      next(it);
    });
  }
  ```
