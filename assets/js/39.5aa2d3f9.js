(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{397:function(n,t,e){"use strict";e.r(t);var s=e(44),i=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"动态规划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[n._v("#")]),n._v(" 动态规划")]),n._v(" "),e("p",[n._v("/**")]),n._v(" "),e("ul",[e("li",[n._v("直方图面积，维护一个递增的栈，当有小于栈顶元素存在时，就出栈并对出栈元素做计算，最后对栈里元素计算")]),n._v(" "),e("li",[n._v("@param {number[]} heights")]),n._v(" "),e("li",[n._v("@return {number}\n*/\nvar largestRectangleArea = function(heights) {\nlet n = heights.length;\nlet i = 0;\nlet max = 0;\nlet stack = [];\nwhile (i < n) {\nwhile (stack.length && heights[i] < heights[stack[stack.length - 1]]) {\nlet top = heights[stack.pop()];\nmax = Math.max(\nmax,\ntop * (i - (stack.length ? stack[stack.length - 1] : -1) - 1)\n);\n}\nstack.push(i++);\n}\nwhile (stack.length > 0) {\nmax = Math.max(\nmax,\nheights[stack.pop()] *\n(n - (stack.length ? stack[stack.length - 1] : -1) - 1)\n);\n}\nreturn max;\n};")])]),n._v(" "),e("p",[n._v("/**\n*下一个更大元素，还是一个栈但是这不再是一个递增的栈，因为是下一个更大的，每一个都要入栈，去留留给下一元素决定，倒叙遍历也是下一个更大的关键点\n*\n*/\nfunction nextGreaterElement(nums1, nums2) {\nconst stack = [];\nconst retMap = {};\nfor (let i = nums2.length - 1; i >= 0; i--) {\nif (stack.length && stack[stack.length - 1] < nums2[i]) {\nstack.pop();\n}\nretMap[nums2[i]] = stack.length ? stack[stack.length - 1] : -1;\nstack.push(nums2[i]);\n}\nfor (i = 0; i < nums1.length; i++) {\nnums1[i] = retMap[nums1[i]];\n}\nreturn nums1;\n}")]),n._v(" "),e("p",[n._v('// 首先是转化符号为正负1，符号栈的构建也是关键\nfunction calc(s) {\nlet sign = 1;\nlet ops = [1];\nlet i = 0;\nlet ret = 0;\nwhile (i < s.length) {\nif (s[i] === " ") {\ni++;\n} else if (s[i] === "+") {\nsign = ops[ops.length - 1];\ni++;\n} else if (s[i] === "-") {\nsign = -ops[ops.length - 1];\ni++;\n} else if (s[i] === "(") {\nops.push(sign);\ni++;\n} else if (s[i] === ")") {\nops.pop();\ni++;\n} else {\nlet num = 0;\nwhile (s[i] !== " " && i < s.length && !isNaN(Number(s[i]))) {\nnum = num * 10 + s[i].charCodeAt() - "0".charCodeAt();\ni++;\n}\nret += sign * num;\n}\n}\nreturn ret;\n}')]),n._v(" "),e("p",[n._v("/**")]),n._v(" "),e("ul",[e("li",[n._v('#号删除,栈的方式\n*/\nvar backspaceCompare = function(s, t) {\nlet sStack = [];\nlet tStack = [];\nfor (let i = 0; i < s.length; i++) {\nif (s[i] === "#") {\nsStack.pop();\n} else {\nsStack.push(s[i]);\n}\n}\nfor (let t = 0; i < t.length; i++) {\nif (t[i] === "#") {\ntStack.pop();\n} else {\ntStack.push(t[i]);\n}\n}\nreturn s.join() === t.join();\n};\n// #号删除滚雪球方式，有区别的是这个删除要倒叙删除，因为是判断字符串是否相等,顺序逆序不用要\nvar backspaceCompare = function(s, t) {\nfunction removeD(str) {\nlet newStr = "";\nlet backCount = 0;\nfor (let fast = str.length - 1; fast >= 0; fast--) {\nif (str[fast] === "#") {\nbackCount++;\n} else {\nif (backCount === 0) {\nnewStr += str[fast];\n} else {\nbackCount--;\n}\n}\n}\nreturn newStr;\n}\nreturn removeD(s) === removeD(t);\n};')])]),n._v(" "),e("p",[n._v("/**")]),n._v(" "),e("ul",[e("li",[n._v("接雨水，还是类似双指针解法，变形的双指针")]),n._v(" "),e("li",[n._v("@param {number[]} height")]),n._v(" "),e("li",[n._v("@return {number}\n*/\nvar trap = function(height) {\nlet left = 0;\nlet right = height.length - 1;\nlet leftMax = 0;\nlet rightMax = 0;\nlet res = 0;\nwhile (left < right) {\nif (height[left] < height[right]) {\nif (height[left] >= leftMax) {\nleftMax = height[left];\n} else {\nres += leftMax - height[left];\n}\nleft++;\n} else {\nif (height[right] >= rightMax) {\nrightMax = height[right];\n} else {\nres += rightMax - height[right];\n}\nright--;\n}\n}\nreturn res;\n};")])]),n._v(" "),e("p",[n._v("/**")]),n._v(" "),e("ul",[e("li",[n._v("双端队列，每次有新的进入需要删除老的小的，把自己放到队伍里再去掉队伍中又大又老的")]),n._v(" "),e("li",[n._v("@param {number[]} nums")]),n._v(" "),e("li",[n._v("@param {number} k")]),n._v(" "),e("li",[n._v("@return {number[]}\n*/\nvar maxSlidingWindow = function(nums, k) {\nlet ans = [];\nlet i = 0;\nlet stack = [];\nwhile (i < k) {\nwhile (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {\nstack.pop();\n}\nstack.push(i);\ni++;\n}\nans[0] = nums[stack[0]];\nfor (i = k; i < nums.length; i++) {\nwhile (stack.length && nums[i] >= nums[stack[stack.length - 1]]) {\nstack.pop();\n}\nstack.push(i);\nwhile (stack[0] <= i - k) {\nstack.shift();\n}\nans.push(nums[stack[0]]);\n}\nreturn ans;\n};")])]),n._v(" "),e("p",[n._v('// 有效括号，这就是典型的栈解法题目\nvar isValid = function(s) {\nlet stack = [];\nfor (let i = 0; i < s.length; i++) {\nconst key = s[i];\nif (key === ")" && stack[stack.length - 1] === "(") {\nstack.pop();\n} else if (key === "]" && stack[stack.length - 1] === "[") {\nstack.pop();\n} else if (key === "}" && stack[stack.length - 1] === "{") {\nstack.pop();\n} else {\nstack.push(key);\n}\n}\nreturn !stack.length;\n};')])])}),[],!1,null,null,null);t.default=i.exports}}]);