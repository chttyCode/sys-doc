(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{389:function(v,_,l){"use strict";l.r(_);var t=l(44),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"队列、栈、双端队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#队列、栈、双端队列"}},[v._v("#")]),v._v(" 队列、栈、双端队列")]),v._v(" "),l("ul",[l("li",[v._v("栈\n"),l("ul",[l("li",[v._v("什么是栈\n"),l("ul",[l("li",[v._v("是一个操作受限制的线性表")])])]),v._v(" "),l("li",[v._v("为什么要有栈这种数据结构\n"),l("ul",[l("li",[v._v("相对数组链表都是线性而且没有操作限制，相对比较自由、容易出错")])])]),v._v(" "),l("li",[v._v("栈的特点\n"),l("ul",[l("li",[v._v("先进后出，后进先出，满足一端出入")])])]),v._v(" "),l("li",[v._v("如何实现栈\n"),l("ul",[l("li",[v._v("顺序栈\n"),l("ul",[l("li",[v._v("用数组实现")]),v._v(" "),l("li",[v._v("时间空间复杂度\n"),l("ul",[l("li",[v._v("O(1)，存在动态扩容的栈在个别时候会退化成 O(n)，在平均情况下还是 o(1)的")])])])])]),v._v(" "),l("li",[v._v("链式栈\n"),l("ul",[l("li",[v._v("用链表实现")])])])])]),v._v(" "),l("li",[v._v("栈的使用场景\n"),l("ul",[l("li",[v._v("函数的调用栈")]),v._v(" "),l("li",[v._v("表达式求值\n"),l("ul",[l("li",[v._v("用两个栈，一个栈存操作数，一个栈存运算符，")]),v._v(" "),l("li",[v._v("遇到操作符优先级高的进栈，优先级低的对左栈取出 2 个操作数进行计算")])])]),v._v(" "),l("li",[v._v("括号匹配\n"),l("ul",[l("li",[v._v("左括号进栈，右括号时，取出左括号进行对比")])])]),v._v(" "),l("li",[v._v("浏览器中的栈\n"),l("ul",[l("li",[v._v("使用两个栈进行模拟\n"),l("ul",[l("li",[v._v("首次访问栈")]),v._v(" "),l("li",[v._v("后退栈")])])])])])])]),v._v(" "),l("li",[v._v("思考\n"),l("ul",[l("li",[v._v("函数执行为什么要用栈来保存临时变量\n"),l("ul",[l("li",[v._v("函数调用符合先进后出，后进先出的特点，函数调用即进栈分配一定的内存空间，出栈即可回收")])])]),v._v(" "),l("li",[v._v("堆栈 vs 栈中的栈意义相同吗")])])])])])]),v._v(" "),l("h1",{attrs:{id:"习题"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#习题"}},[v._v("#")]),v._v(" 习题")]),v._v(" "),l("ul",[l("li",[v._v("20")]),v._v(" "),l("li",[v._v("155")]),v._v(" "),l("li",[v._v("232")]),v._v(" "),l("li",[v._v("844")]),v._v(" "),l("li",[v._v("224")]),v._v(" "),l("li",[v._v("682")]),v._v(" "),l("li",[v._v("496")]),v._v(" "),l("li",[v._v("84")]),v._v(" "),l("li",[v._v("239")]),v._v(" "),l("li",[v._v("649")]),v._v(" "),l("li",[v._v("42")])]),v._v(" "),l("h1",{attrs:{id:"队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[v._v("#")]),v._v(" 队列")]),v._v(" "),l("p",[v._v("队列和栈一样也是一种操作受限的线性数据结构，这种结构的好处就是可以避免出错")]),v._v(" "),l("p",[v._v("队列是对头出，队尾入，只有这两个操作，生活场景就是排队吃饭，你总要限制排队的规则，不能顺便进出，既然生活种有这种需求那程序抽象必然也需要")]),v._v(" "),l("h2",{attrs:{id:"队列的实现方式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#队列的实现方式"}},[v._v("#")]),v._v(" 队列的实现方式")]),v._v(" "),l("p",[v._v("用数组实现叫顺序栈")]),v._v(" "),l("p",[v._v("存在的问题：数据挪移")]),v._v(" "),l("p",[v._v("用链表实现叫链式栈")]),v._v(" "),l("p",[v._v("存在的问题：无边界，队列无法控制与预判")]),v._v(" "),l("h2",{attrs:{id:"工程种常用的队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#工程种常用的队列"}},[v._v("#")]),v._v(" 工程种常用的队列")]),v._v(" "),l("h3",{attrs:{id:"循环队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#循环队列"}},[v._v("#")]),v._v(" 循环队列")]),v._v(" "),l("p",[v._v("解决了顺序队列种的数据搬移问题，可以实现并发队列")]),v._v(" "),l("h3",{attrs:{id:"阻塞队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[v._v("#")]),v._v(" 阻塞队列")]),v._v(" "),l("p",[v._v("当队列空时对对头操作有限制")]),v._v(" "),l("p",[v._v("当队列满时对队尾操作有限制")]),v._v(" "),l("p",[v._v("eg: 生产-消费这模型")]),v._v(" "),l("h3",{attrs:{id:"并发队列"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#并发队列"}},[v._v("#")]),v._v(" 并发队列")]),v._v(" "),l("p",[v._v("对队列进行加锁控制，可以解决并发队列的问题，但对锁的粒度有要求")]),v._v(" "),l("p",[v._v("可以考虑循环队列，处理并发问题")]),v._v(" "),l("h2",{attrs:{id:"习题-2"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#习题-2"}},[v._v("#")]),v._v(" 习题")]),v._v(" "),l("ul",[l("li",[v._v("622")])])])}),[],!1,null,null,null);_.default=a.exports}}]);