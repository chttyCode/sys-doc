(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{393:function(v,_,l){"use strict";l.r(_);var i=l(44),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"v8-工作原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#v8-工作原理"}},[v._v("#")]),v._v(" V8 工作原理")]),v._v(" "),l("h2",{attrs:{id:"数据存储形式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据存储形式"}},[v._v("#")]),v._v(" 数据存储形式")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("虽然 Js 不需要手动管理内存，但打造高性能 web 应用还是需要了解 JS 的数据是如果存储的")])]),v._v(" "),l("li",[l("p",[v._v("JS 是弱类型、动态语言")]),v._v(" "),l("ul",[l("li",[v._v("弱类型\n"),l("ul",[l("li",[v._v("定义变量时无需定义类型")])])]),v._v(" "),l("li",[v._v("动态语言\n"),l("ul",[l("li",[v._v("运行是可以改变变量类型")])])])])]),v._v(" "),l("li",[l("p",[v._v("JS 的有八种变量类型")]),v._v(" "),l("table",[l("thead",[l("tr",[l("th",[v._v("类型")]),v._v(" "),l("th",[v._v("描述")])])]),v._v(" "),l("tbody",[l("tr",[l("td",[v._v("Boolean")]),v._v(" "),l("td",[v._v("只有 true 和 false")])]),v._v(" "),l("tr",[l("td",[v._v("Null")]),v._v(" "),l("td",[v._v("只有一个值 null")])]),v._v(" "),l("tr",[l("td",[v._v("Undefined")]),v._v(" "),l("td",[v._v("没有被赋值的变量")])]),v._v(" "),l("tr",[l("td",[v._v("Number")]),v._v(" "),l("td",[v._v("基于 IEEE754 标准的双精度 64 位二进制值")])]),v._v(" "),l("tr",[l("td",[v._v("BigInt")]),v._v(" "),l("td",[v._v("新类型，表示任意精度整数")])]),v._v(" "),l("tr",[l("td",[v._v("String")]),v._v(" "),l("td",[v._v("字符串，不可更改")])]),v._v(" "),l("tr",[l("td",[v._v("Symbol")]),v._v(" "),l("td",[v._v("符合类型，通常被用作 Object 的 key")])]),v._v(" "),l("tr",[l("td",[v._v("Object")]),v._v(" "),l("td",[v._v("属性的集合")])])])]),v._v(" "),l("ul",[l("li",[v._v("typeof null 是 Object，主要为了兼容，一直没修复")]),v._v(" "),l("li",[v._v("JS 中一切皆对象")]),v._v(" "),l("li",[v._v("8 种类型种分为 7 种基本类型、1 种引用类型\n"),l("ul",[l("li",[v._v("基本类型是值拷贝")]),v._v(" "),l("li",[v._v("引用类型是地址拷贝")])])])])]),v._v(" "),l("li",[l("p",[v._v("存储空间分为三种")]),v._v(" "),l("ul",[l("li",[v._v("代码空间\n"),l("ul",[l("li",[v._v("存放可执行代码")])])]),v._v(" "),l("li",[v._v("栈空间\n"),l("ul",[l("li",[v._v("存储执行上下文")])])]),v._v(" "),l("li",[v._v("堆空间\n"),l("ul",[l("li",[v._v("存储大块数据即 Object 类型")])])]),v._v(" "),l("li",[v._v("栈空间 vs 堆空间\n"),l("ul",[l("li",[v._v("栈空间执行上下文需要频繁切换，所以内存空间大小有限")]),v._v(" "),l("li",[v._v("为了切换提高切换性能，上下文中只存放基本类型&引用类型的地址")]),v._v(" "),l("li",[v._v("堆空间用来存放大块数据\n"),l("ul",[l("li",[v._v("缺点\n"),l("ul",[l("li",[v._v("分配回收内存需要一定时间")])])])])])])])])])]),v._v(" "),l("h2",{attrs:{id:"垃圾数据回收"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#垃圾数据回收"}},[v._v("#")]),v._v(" 垃圾数据回收")]),v._v(" "),l("ul",[l("li",[v._v("清楚了内存分配的方式，对使用后的垃圾数据怎么处理同样重要，")]),v._v(" "),l("li",[v._v("JS 的产生的垃圾数据由垃圾回收处理器来释放")]),v._v(" "),l("li",[v._v("栈中数据的回收\n"),l("ul",[l("li",[v._v("栈中数据通过 ESP 指针来表示")]),v._v(" "),l("li",[v._v("出栈是指 ESP 的指针下移，当前上下文会被无效内存，会被后续入栈上下问覆盖")])])]),v._v(" "),l("li",[v._v("堆中数据的回收\n"),l("ul",[l("li",[v._v("需要垃圾回收器回收")]),v._v(" "),l("li",[v._v("首先了解一下代际假说\n"),l("ul",[l("li",[v._v("代际假说\n"),l("ul",[l("li",[v._v("大部分对象在内存中存活的时都很短、简单来说就是对象一经分配很快就变得不可访问")]),v._v(" "),l("li",[v._v("不死的对象活得更久")])])])])]),v._v(" "),l("li",[v._v("根据代际假说，v8 采用分代收集，即新生代、老生代，新生代中存放生存时间短的对象、老生代存放生存时间长的对象\n"),l("ul",[l("li",[v._v("新生代\n"),l("ul",[l("li",[v._v("通常内存在 1-8M 之间")])])]),v._v(" "),l("li",[v._v("老生代\n"),l("ul",[l("li",[v._v("通常内存空间比较大")])])])])]),v._v(" "),l("li",[v._v("垃圾清理流程\n"),l("ul",[l("li",[v._v("标记：遍历内存空间，到执行栈中查找是否有引用该内存的变量")]),v._v(" "),l("li",[v._v("回收：回收非活动对象")]),v._v(" "),l("li",[v._v("整理：频繁的内存回收会造成大量的内存碎片，需要进行内存整理")]),v._v(" "),l("li",[v._v("新生代回收\n"),l("ul",[l("li",[v._v("采用 Scavenge 算法，把新生代划分会对象区和空闲区")]),v._v(" "),l("li",[v._v("新加入的对象都加入到对象区，在对象区快被写满时执行一次清理")]),v._v(" "),l("li",[v._v("清理阶段\n"),l("ul",[l("li",[v._v("标记")]),v._v(" "),l("li",[v._v("将对象区中存活的对象复制到空闲区")]),v._v(" "),l("li",[v._v("复制完成后将空闲区和对象区进行角色翻转")])])]),v._v(" "),l("li",[v._v("存在的问题\n"),l("ul",[l("li",[v._v("新生代垃圾回收通过复制翻转的方式进行，为了执行效率，内存空间一般比较小很容易被写满")]),v._v(" "),l("li",[v._v("解决方式\n"),l("ul",[l("li",[v._v("对象晋级策略\n"),l("ul",[l("li",[v._v("经过 2 次垃圾回收依然存活的对象会被移动到老生代中")])])])])])])])])]),v._v(" "),l("li",[v._v("老生代回收\n"),l("ul",[l("li",[v._v("除了新生代晋级的对象、一些大对象也会被直接分配到老生代中")]),v._v(" "),l("li",[v._v("老生代的数据一般比较大，内存空间也比较大，不适合 Scavenge 算法")]),v._v(" "),l("li",[v._v("老生代采用标记整理的算法进行垃圾回收\n"),l("ul",[l("li",[v._v("过程和标记清楚一样，也需要标记，不过不再是直接清除")]),v._v(" "),l("li",[v._v("标记后让所有存活的对象向一端移动")]),v._v(" "),l("li",[v._v("清理掉边界以外的对象")])])]),v._v(" "),l("li",[v._v("存在的问题\n"),l("ul",[l("li",[v._v("js 在主线程执行，一旦执行垃圾回收，会暂停脚本执行，造成全停顿现象")]),v._v(" "),l("li",[v._v("解决方式\n"),l("ul",[l("li",[v._v("增量标记清除、将清理任务拆分为很多个子任务，穿插执行")])])])])])])])])])])])]),v._v(" "),l("h2",{attrs:{id:"编译器-解释器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#编译器-解释器"}},[v._v("#")]),v._v(" 编译器&解释器")])])}),[],!1,null,null,null);_.default=t.exports}}]);