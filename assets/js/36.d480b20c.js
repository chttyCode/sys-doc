(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{394:function(v,_,l){"use strict";l.r(_);var i=l(44),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"v8-工作原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#v8-工作原理"}},[v._v("#")]),v._v(" V8 工作原理")]),v._v(" "),l("h2",{attrs:{id:"数据存储形式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#数据存储形式"}},[v._v("#")]),v._v(" 数据存储形式")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("虽然 Js 不需要手动管理内存，但打造高性能 web 应用还是需要了解 JS 的数据是如果存储的")])]),v._v(" "),l("li",[l("p",[v._v("JS 是弱类型、动态语言")]),v._v(" "),l("ul",[l("li",[v._v("弱类型\n"),l("ul",[l("li",[v._v("定义变量时无需定义类型")])])]),v._v(" "),l("li",[v._v("动态语言\n"),l("ul",[l("li",[v._v("运行是可以改变变量类型")])])])])]),v._v(" "),l("li",[l("p",[v._v("JS 的有八种变量类型")]),v._v(" "),l("table",[l("thead",[l("tr",[l("th",[v._v("类型")]),v._v(" "),l("th",[v._v("描述")])])]),v._v(" "),l("tbody",[l("tr",[l("td",[v._v("Boolean")]),v._v(" "),l("td",[v._v("只有 true 和 false")])]),v._v(" "),l("tr",[l("td",[v._v("Null")]),v._v(" "),l("td",[v._v("只有一个值 null")])]),v._v(" "),l("tr",[l("td",[v._v("Undefined")]),v._v(" "),l("td",[v._v("没有被赋值的变量")])]),v._v(" "),l("tr",[l("td",[v._v("Number")]),v._v(" "),l("td",[v._v("基于 IEEE754 标准的双精度 64 位二进制值")])]),v._v(" "),l("tr",[l("td",[v._v("BigInt")]),v._v(" "),l("td",[v._v("新类型，表示任意精度整数")])]),v._v(" "),l("tr",[l("td",[v._v("String")]),v._v(" "),l("td",[v._v("字符串，不可更改")])]),v._v(" "),l("tr",[l("td",[v._v("Symbol")]),v._v(" "),l("td",[v._v("符合类型，通常被用作 Object 的 key")])]),v._v(" "),l("tr",[l("td",[v._v("Object")]),v._v(" "),l("td",[v._v("属性的集合")])])])]),v._v(" "),l("ul",[l("li",[v._v("typeof null 是 Object，主要为了兼容，一直没修复")]),v._v(" "),l("li",[v._v("JS 中一切皆对象")]),v._v(" "),l("li",[v._v("8 种类型种分为 7 种基本类型、1 种引用类型\n"),l("ul",[l("li",[v._v("基本类型是值拷贝")]),v._v(" "),l("li",[v._v("引用类型是地址拷贝")])])])])]),v._v(" "),l("li",[l("p",[v._v("存储空间分为三种")]),v._v(" "),l("ul",[l("li",[v._v("代码空间\n"),l("ul",[l("li",[v._v("存放可执行代码")])])]),v._v(" "),l("li",[v._v("栈空间\n"),l("ul",[l("li",[v._v("存储执行上下文")])])]),v._v(" "),l("li",[v._v("堆空间\n"),l("ul",[l("li",[v._v("存储大块数据即 Object 类型")])])]),v._v(" "),l("li",[v._v("栈空间 vs 堆空间\n"),l("ul",[l("li",[v._v("栈空间执行上下文需要频繁切换，所以内存空间大小有限")]),v._v(" "),l("li",[v._v("为了切换提高切换性能，上下文中只存放基本类型&引用类型的地址")]),v._v(" "),l("li",[v._v("堆空间用来存放大块数据\n"),l("ul",[l("li",[v._v("缺点\n"),l("ul",[l("li",[v._v("分配回收内存需要一定时间")])])])])])])])])])]),v._v(" "),l("h2",{attrs:{id:"垃圾数据回收"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#垃圾数据回收"}},[v._v("#")]),v._v(" 垃圾数据回收")]),v._v(" "),l("ul",[l("li",[v._v("清楚了内存分配的方式，对使用后的垃圾数据怎么处理同样重要，")]),v._v(" "),l("li",[v._v("JS 的产生的垃圾数据由垃圾回收处理器来释放")]),v._v(" "),l("li",[v._v("栈中数据的回收\n"),l("ul",[l("li",[v._v("栈中数据通过 ESP 指针来表示")]),v._v(" "),l("li",[v._v("出栈是指 ESP 的指针下移，当前上下文会被无效内存，会被后续入栈上下问覆盖")])])]),v._v(" "),l("li",[v._v("堆中数据的回收\n"),l("ul",[l("li",[v._v("需要垃圾回收器回收")]),v._v(" "),l("li",[v._v("首先了解一下代际假说\n"),l("ul",[l("li",[v._v("代际假说\n"),l("ul",[l("li",[v._v("大部分对象在内存中存活的时都很短、简单来说就是对象一经分配很快就变得不可访问")]),v._v(" "),l("li",[v._v("不死的对象活得更久")])])])])]),v._v(" "),l("li",[v._v("根据代际假说，v8 采用分代收集，即新生代、老生代，新生代中存放生存时间短的对象、老生代存放生存时间长的对象\n"),l("ul",[l("li",[v._v("新生代\n"),l("ul",[l("li",[v._v("通常内存在 1-8M 之间")])])]),v._v(" "),l("li",[v._v("老生代\n"),l("ul",[l("li",[v._v("通常内存空间比较大")])])])])]),v._v(" "),l("li",[v._v("垃圾清理流程\n"),l("ul",[l("li",[v._v("标记：遍历内存空间，到执行栈中查找是否有引用该内存的变量")]),v._v(" "),l("li",[v._v("回收：回收非活动对象")]),v._v(" "),l("li",[v._v("整理：频繁的内存回收会造成大量的内存碎片，需要进行内存整理")]),v._v(" "),l("li",[v._v("新生代回收\n"),l("ul",[l("li",[v._v("采用 Scavenge 算法，把新生代划分会对象区和空闲区")]),v._v(" "),l("li",[v._v("新加入的对象都加入到对象区，在对象区快被写满时执行一次清理")]),v._v(" "),l("li",[v._v("清理阶段\n"),l("ul",[l("li",[v._v("标记")]),v._v(" "),l("li",[v._v("将对象区中存活的对象复制到空闲区")]),v._v(" "),l("li",[v._v("复制完成后将空闲区和对象区进行角色翻转")])])]),v._v(" "),l("li",[v._v("存在的问题\n"),l("ul",[l("li",[v._v("新生代垃圾回收通过复制翻转的方式进行，为了执行效率，内存空间一般比较小很容易被写满")]),v._v(" "),l("li",[v._v("解决方式\n"),l("ul",[l("li",[v._v("对象晋级策略\n"),l("ul",[l("li",[v._v("经过 2 次垃圾回收依然存活的对象会被移动到老生代中")])])])])])])])])]),v._v(" "),l("li",[v._v("老生代回收\n"),l("ul",[l("li",[v._v("除了新生代晋级的对象、一些大对象也会被直接分配到老生代中")]),v._v(" "),l("li",[v._v("老生代的数据一般比较大，内存空间也比较大，不适合 Scavenge 算法")]),v._v(" "),l("li",[v._v("老生代采用标记整理的算法进行垃圾回收\n"),l("ul",[l("li",[v._v("过程和标记清楚一样，也需要标记，不过不再是直接清除")]),v._v(" "),l("li",[v._v("标记后让所有存活的对象向一端移动")]),v._v(" "),l("li",[v._v("清理掉边界以外的对象")])])]),v._v(" "),l("li",[v._v("存在的问题\n"),l("ul",[l("li",[v._v("js 在主线程执行，一旦执行垃圾回收，会暂停脚本执行，造成全停顿现象")]),v._v(" "),l("li",[v._v("解决方式\n"),l("ul",[l("li",[v._v("增量标记清除、将清理任务拆分为很多个子任务，穿插执行")])])])])])])])])])])])]),v._v(" "),l("h2",{attrs:{id:"编译器-解释器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#编译器-解释器"}},[v._v("#")]),v._v(" 编译器&解释器")]),v._v(" "),l("ul",[l("li",[v._v("已经了解了 javascript 的执行，存储、和垃圾回收，那我们编写的高级语言代码又是如何被 v8 执行的呢？\n"),l("ul",[l("li",[v._v("编译器(Compiler)\n"),l("ul",[l("li",[v._v("直接将高级代码编译成二进制文件")])])]),v._v(" "),l("li",[v._v("解释器(Interpreter)\n"),l("ul",[l("li",[v._v("每次运行时都需要进行动态解释并执行")])])]),v._v(" "),l("li",[v._v("抽象语法树(AST)\n"),l("ul",[l("li",[v._v("代码的结构性描述")])])]),v._v(" "),l("li",[v._v("字节码(ByteCode)\n"),l("ul",[l("li",[v._v("基于抽象语法树与二进制文件的中间产物")])])]),v._v(" "),l("li",[v._v("即时编译(JIT)\n"),l("ul",[l("li",[v._v("字节码配合解释器和编译器的技术")])])]),v._v(" "),l("li",[v._v("v8 如何执行 javascript\n"),l("blockquote",[l("p",[v._v("v8 的执行过程中即有解释器又有编辑器")])]),v._v(" "),l("ul",[l("li",[v._v("生成抽象语法树（AST）和执行上下文\n"),l("blockquote",[l("p",[v._v("将源代码转换为抽象语法树，并生成执行上下文")])]),v._v(" "),l("ul",[l("li",[v._v("生成 AST 需要经过两个阶段\n"),l("ul",[l("li",[v._v("第一阶段是分词（tokenize），又称为词法分析\n"),l("ul",[l("li",[v._v("将代码按 token 进行拆解")])])]),v._v(" "),l("li",[v._v("第二阶段是解析（parse），又称为语法分析\n"),l("ul",[l("li",[v._v("将 token 按语法规则转为 AST")])])])])]),v._v(" "),l("li",[v._v("有了 AST，v8 会生成该段代码的执行上下文")])])]),v._v(" "),l("li",[v._v("生成字节码\n"),l("blockquote",[l("p",[v._v("有了 AST、上下文，解释器会根据 AST 生成字节码，并解释执行\n其实一开始 v8 并没有生成字节码，而是直接将 AST 转为机器码，因为其执行效率高，但是机器码较字节码更占内存，为解决内存占用的问题，引入了字节码")])]),v._v(" "),l("ul",[l("li",[v._v("字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行")])])]),v._v(" "),l("li",[v._v("执行代码\n"),l("blockquote",[l("p",[v._v("生成字节码之后，接下来就要进入执行阶段了")])]),v._v(" "),l("ul",[l("li",[v._v("解释器会追行解释执行代码，对执行过程中的热点代码会进行标注识别为热点代码")]),v._v(" "),l("li",[v._v("对热点代码会启用编译器进行编译，编译成机器码，提升执行效率")])])])])])])]),v._v(" "),l("li",[v._v("javascript 性能优化\n"),l("ul",[l("li",[v._v("提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；")]),v._v(" "),l("li",[v._v("避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；")]),v._v(" "),l("li",[v._v("减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);